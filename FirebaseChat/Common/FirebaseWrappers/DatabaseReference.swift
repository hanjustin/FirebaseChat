
import Foundation
import FirebaseDatabase

/*
 Classes declared in the same source file to use private property & method in the parent class (DatabaseReference).
 Swift does not have 'protected' access control that some other languages have.
 Not sure if having multiple classes in one source file is the best practice.
 
------------------------------------------------------------------------------------------------------------------
 Firebase uses database reference to retrieve and update data.
 For example, the reference "/users/uniqueID1/email" could be used to get or update the user's email address.
 
 [String : AnyObject] dictionary form of data is retrieved or used to update the database reference.
 i.e.
 Data retrieved at "/users/uniqueID1" can be in a form of: ["email" : "email@gmail.com", "name" "John", ...]
*/

// MARK:- DatabaseReference

class DatabaseReference: NSObject {
    enum RootRefKey: String {
        case chatRooms
        case chatRoom_Messages
        case users
        case user_Friends
        case user_FriendRequests
        case user_ChatRooms
    }
    
    private lazy var reference: FIRDatabaseReference = DatabaseReference.RootRef
    private static var RootRef: FIRDatabaseReference { return FIRDatabase.database().reference() }
    private var refComponents = [String]()
    
    var referencePath: String { return refComponents.joined(separator: "/") }
    var key: String { return refComponents.last ?? "" }
    
    required init(referencePath: String) {
        super.init()
        self.refComponents = refComponentsFrom(path: referencePath)
        self.reference = reference.child(referencePath)
    }
    
    required convenience init(pathComponents: String...) {
        self.init(referencePath: pathComponents.joined(separator: "/"))
    }
    
    required convenience init(DBObject: DatabaseObject) {
        self.init(pathComponents: DBObject.dynamicType.RootRefKey, DBObject.uniqueID)
    }
    
    required convenience init(rootRef: RootRefKey, ObjectID: String = "") {
        self.init(pathComponents: rootRef.rawValue, ObjectID)
    }
    
    func childByAutoID() -> Self {
        let autoGeneratedID = reference.childByAutoId().key
        return appendedChildPath(autoGeneratedID)
    }
    
    func appendedChildPath(_ childPath: String) -> Self {
        return self.dynamicType.init(pathComponents: referencePath, childPath)
    }
    
    private func refComponentsFrom(path: String) -> [String] {
        return path.components(separatedBy: "/").flatMap { $0.nonEmptyValue }
    }
}

// MARK:- DatabaseUpdater

class DatabaseUpdater: DatabaseReference {
    private var stagedUpdates: [String : AnyObject] = [:]
    
    required init(referencePath: String) {
        super.init(referencePath: referencePath)
    }
}

extension DatabaseUpdater {
    static func updateDatabase(with object: DatabaseObject, completionHandler: ((NSError?) -> Void)? = nil) {
        self.init(DBObject: object).updateChildReference(with: object.toDictionary(), completionHandler: completionHandler)
    }
    
    static func commitUpdates(of updaters: DatabaseUpdater..., completionHandler: ((NSError?) -> Void)? = nil) {
        let combinedUpdates = updaters.map { $0.stagedUpdates }.reduce([:]) {$0 + $1}
        
        RootRef.updateChildValues(combinedUpdates) { error, _ in
            if error == nil { updaters.forEach { $0.stagedUpdates = [:] } }
            completionHandler?(error)
        }
    }
    
    func stageUpdate(value: AnyObject?) -> Self {
        return stageChildUpdate(value: value)
    }
    
    func stageChildUpdate(pathComponents: String..., value: AnyObject?) -> Self{
        let fullPath = (refComponents + pathComponents).joined(separator: "/")
        stagedUpdates[fullPath] = value ?? NSNull()      // NSNull is used to delete value
        return self
    }
}

private extension DatabaseUpdater {
    func overwriteValueWith(value: AnyObject?, completionHandler: ((NSError?) -> Void)? = nil) {
        reference.setValue(value) { error, firRef in
            completionHandler?(error)
        }
    }
    
    func updateChildReference(with dict: [String : AnyObject], completionHandler: ((NSError?) -> Void)? = nil) {
        reference.updateChildValues(dict) { error, _ in
            completionHandler?(error)
        }
    }
}

// MARK:- DatabaseObserver

class DatabaseObserver : DatabaseReference {
    typealias KVP<Key, Value> = (key: Key, value: Value)
    
    enum EventType: Int {   // One to one mapping enum to FIRDataEventType
        case childAdded
        case childRemoved
        case childChanged
        case childMoved
        case value
    }
    
    enum QueryRelation {
        case lessThanOrEqual
        case equal
        case greaterThanOrEqual
    }

    private var query: FIRDatabaseQuery?
    private var observer: FIRDatabaseQuery { return query ?? reference }
    private lazy var childObservers = [DatabaseObserver]()
    
    required init(referencePath: String) {
        super.init(referencePath: referencePath)
    }
}

extension DatabaseObserver {
    static func fetchObject<DBObject: DatabaseObject>(
        type dbObjectType: DBObject.Type,
        id: String,
        completionHandler: (DBObject) -> Void)
    {
        let objectObserver = self.init(pathComponents: DBObject.RootRefKey, id)
        objectObserver.getChildrenDictionary { propertyDict in
            let fetchedObject = dbObjectType.init(uniqueID: id, propertyDict: propertyDict)
            completionHandler(fetchedObject)
        }
    }
    
    override func appendedChildPath(_ childPath: String) -> Self {
        return childObserverWith(childPath: childPath)
    }
    
    func observe<T>(event: EventType, withBlock block: (KVP<String, T>) -> Void) {
        let firEventType = mappedFIREventType(from: event)
        observer.observe(firEventType) { (snapshot: FIRDataSnapshot) in
            if let castedData = snapshot.value as? T { block(key: snapshot.key, value: castedData) }
        }
    }
    
    // Query can find 0 result that returns null, so the value is optional
    func observeOnceFor<T>(event: EventType, withBlock block: (KVP<String, T?>) -> Void) {
        let firEventType = mappedFIREventType(from: event)
        observer.keepSynced(true)  // This is to get the latest data. Firebase caches queries and can return old data
        observer.observeSingleEvent(of: firEventType) { (snapshot: FIRDataSnapshot) in
            block(key: snapshot.key, value: snapshot.value as? T)
        }
    }

    func stopAllObservings() {
        observer.removeAllObservers()
        childObservers.forEach { $0.stopAllObservings() }
        childObservers = []
    }
    
    func setQuery(keypath: String, relatedBy relation: QueryRelation, value: AnyObject) -> Self {
        query = observer.queryOrdered(byChild: keypath)
        return setQuery(relation, value: value)
    }
    
    func setQueryValue(relatedBy relation: QueryRelation, value: AnyObject) -> Self {
        query = observer.queryOrderedByValue()
        return setQuery(relation, value: value)
    }
    
    private func setQuery(_ relation: QueryRelation, value: AnyObject) -> Self {
        switch relation {
        case .lessThanOrEqual:
            query = observer.queryStarting(atValue: value)
        case .equal:
            query = observer.queryEqual(toValue: value)
        case .greaterThanOrEqual:
            query = observer.queryEnding(atValue: value)
        }
        
        return self
    }
    
    func dereferenceIDIndexTo<DBObject: DatabaseObject>(
        type: DBObject.Type,
        currentListHandler: ([DBObject]) -> Void,
        newObjectHandler: (DBObject) -> Void)
    {
        let currentListHandlerFormatter = { (objectVPs: [KVP<DBObject, AnyObject>]) in
            let objects = objectVPs.map { $0.key }
            currentListHandler(objects)
        }

        let newObjectHandlerFormatter = { (objectVP: KVP<DBObject, AnyObject>) in
            let databaseObject = objectVP.key
            newObjectHandler(databaseObject)
        }
        
        dereferenceIDIndexTo(type: type,
                             currentListHandler: currentListHandlerFormatter,
                             newObjectHandler: newObjectHandlerFormatter)
    }
    
    // Get objects by referencing IDIndex to a database node
    // IDIndex has IDs as keys in the node. The ID is a uniqueID of an object in another node.
    func dereferenceIDIndexTo<DBObject: DatabaseObject, Value: AnyObject>(
        type: DBObject.Type,
        currentListHandler: ([KVP<DBObject, Value>]) -> Void,
        newObjectHandler: (KVP<DBObject, Value>) -> Void)
    {
        // Firebase's .ChildAdded event gets called for all existing items and new item that gets added.
        // Firebase's .Value event type gets called after .ChildAdded.
        // This bool property will prevent existing items getting passed to the handler in .ChildAdded observer
        var completedInitialFetch = false
        
        observe(event: .childAdded) { (key, value: Value) in
            guard completedInitialFetch else { return }
            
            DatabaseObserver.fetchObject(type: DBObject.self, id: key) { object in
                newObjectHandler(KVP(object, value))
            }
        }
        
        getObjectValuePairsUsingKeysAsIDs { (OVPs: [KVP<DBObject, Value>]) in
            currentListHandler(OVPs)
            completedInitialFetch = true
        }
    }
}

private extension DatabaseObserver {
    func childObserverWith(childPath: String) -> Self {
        let childObserver = self.dynamicType.init(pathComponents: referencePath, childPath)
        childObservers.append(childObserver)
        return childObserver
    }
    
    func mappedFIREventType(from eventType: EventType) -> FIRDataEventType {
        guard let FIRDataEvent = FIRDataEventType(rawValue: eventType.rawValue) else { fatalError("Failed initializing FIRDataEventType enum. Check FIRDataEventType and EventType enums rawvalues") }
        return FIRDataEvent
    }
    
    func getObjectValuePairsUsingKeysAsIDs<DBObject: DatabaseObject, Value: AnyObject>
        (_ ovpsHandler: ([KVP<DBObject, Value>]) -> Void)
    {
        getChildrenDictionary { (dict) in
            let kvps = dict as? [String : Value] ?? [:]
            let numberOfObjectsToFetch = kvps.count
            var objectVPs: [KVP<DBObject, Value>] = [] {
                didSet { if objectVPs.count == numberOfObjectsToFetch { ovpsHandler(objectVPs) } }
            }
            
            for kvp in kvps {
                DatabaseObserver.fetchObject(type: DBObject.self, id: kvp.key) { object in
                    objectVPs.append((object, kvp.value))
                }
            }
        }
    }

    func getChildrenDictionary(childrenKVPHandler: ([String : AnyObject]) -> Void) {
        observeOnceFor(event: .value) { (_, childrenDict: [String : AnyObject]?) in
            childrenKVPHandler(childrenDict ?? [:])
        }
    }
}

private func +<K,V>(lhs: Dictionary<K,V>, rhs: Dictionary<K,V>) -> Dictionary<K,V>{
    var combinedDict = lhs
    rhs.forEach { (key, value) in combinedDict[key] = value }
    return combinedDict
}
